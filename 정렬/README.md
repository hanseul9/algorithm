# 정렬

🍮버블정렬, 선택정렬, 삽입정렬, 계수정렬은 [10817 세 수] 에 구현해놓음  
🍮병합정렬은 [2751 수 정렬하기 2] 에 구현해놓음  
  
---
  
### 버블 정렬  
**bubble sort -  O(n^2)**  
인접한 두 원소를 비교하고 필요한 경우 위치를 교환하여 정렬하는 알고리즘  
  
<img src="https://github.com/hanseul9/algorithm/assets/102939057/1874e70c-c6bd-44a3-966e-2b795cdf73df" width="400">  
  
🌟이중for문 돌리면서 제일 큰 수는 맨 오른쪽으로 밀어버림. 그럼 맨 오른쪽은 정렬이 끝난거니 거길 제외하고 for문을 돌게됨  
이중 for문이라 성능은 n^2  
  
---  
  
### 선택정렬  
**Selection Sort - O(n^2)**  
정렬되지 않은 부분에서 **최솟값을 선택**하여 정렬된 부분의 마지막에 추가하는 방식으로 정렬하는 알고리즘  
  
<img src="https://github.com/hanseul9/algorithm/assets/102939057/1f699772-7e51-41c6-a6fc-f8314179c641" width="400">  
  
🌟이중으로 돌면서 최소값을 구하고 왼쪽으로 밀어버림. 
이때 왼쪽의 정렬된 요소들은 제외하고 안쪽에서 돌면서 또 최솟값 구하고 정렬된 요소들을 제외한 배열의 첫번째와 최소값을 swap  
  
  
---  
  
### 삽입정렬  
**insertion sort - O(n^2)**  
배열 요소를 하나씩 삽입하면서 정렬하는 알고리즘. 배열 첫 번째 요소는 이미 삽입했다 가정하고 나머지 요소들을 하나씩 삽입함  
  
<img src="https://github.com/hanseul9/algorithm/assets/102939057/12781d15-f2e9-46c6-a696-e52d9a6eb184" width="500">  
  
🌟왼쪽에 정렬된 요소들을 두는 것. 이중 반복문을 돌면서 삽입할 요소를 하나씩 이미 정렬된 요소들 사이에 끼워넣음.  
삽입될 위치는 if문으로 오른쪽으로 밀면서 만들고 안쪽 루프가 종료되면 삽입하여줌  
  
  
---  
  
### 계수 정렬
**Counting sort - O(n+k)**
원소간 비교하지 않고 각 원소가 몇개 등장하는지 갯수를 세서 정렬하는 알고리즘.  
빠르지만 다음과 같은 제약사항을 갖는다  
```
1. 데이터(값)은 양수여야 한다.
2. 값의 범위가 너무 크지 않아야 한다.(메모리 사이즈를 넘어서는 안된다.)
```  
배열을 사용해야하기 때문에 위같은 제약사항이 존재함. (배열의 인덱스는 양수만 존재하고 메모리 이상 활용하지 못하기 때문)  
  
  
<details>
<summary>🔎자세한 방법</summary>
  
1. 원본 데이터를 저장한다.  
  
2. count 배열에 각 숫자가 몇 번 나왔는지 저장한다. 원본 배열의 요소를 count배열의 index에 대응하여 저장한다.
   
3. count 배열을 통해 sum배열을 만들어준다. sum 배열은 내 앞에 숫자가 몇 개 있느냐를 세어준다.
count 배열에 저장되어있는 배열 요소의 개수를 통해 판단하고 마찬가지로 index에 대응하여 앞에 몇 개의 숫자가 있는지 저장한다. 이때 “앞에 있는 수” 는 자기 자신도 포함한다.
여기서 결론적으로 sum 배열은 각각의 요소가 정렬된 배열의 어디에 위치해야하는지 표시하는 것과 같아진다.  
  
4. 마지막으로 정렬 배열에 정리해준다. 원본 배열의 마지막 인덱스부터 순회하여 원본 배열의 요소의 위치는 sum배열에 있으니 sum배열을 통해 정렬 배열에 넣어주고, 다음에 넣을 동일한 값의 요소를 위해 sum배열의 값을 -1 해준다.
   
</details>
  
  
보면 알겠지만 배열에서 사용하지 않는 공간이 많기 때문에 메모리 낭비가 심하다. 
명확한 데이터의 제한이 있다면 이득인 정렬.  

<details>
<summary>역순으로 도는 이유</summary>

  10817 세 수의 couting 구현 메소드를 보면 4번 단계에서 역순으로 도는데, couting sort의 stable한 특성을 깨지게 하지 않기 위해서이다.  

  예를 들어 [ 1, 3(a), 6, 5, 3(b) 2, 4 ] 라는 배열이 있다면 역순으로 돌아야 [ ..., 3(a), 3(b), ... ] 와 같이 순서대로 정렬되기 때문.  

  해당 배열의 sum 배열에서 sum[3] = 4 일 것이고 즉 "4번째" 에 삽입되고 sum[3]--; 가 이뤄져서 sum[3] = 3 이 되어 다음의 3은 "3번째"에 삽입될 것이다.  

  따라서 역순으로 돌아야 stable하게 정렬이 가능해진다.

</details>
  
  
  
---  
  
### 병합 정렬
**Merge Sort - O(nlogn)**  
반으로 나눈 뒤에 각각 정렬하고, 정렬된 두 개의 배열을 합치는 과정을 반복하여 정렬하는 알고리즘  
분할 정복 알고리즘을 기반으로 정렬되는 방식  
  
<details>
<summary>🔎자세한 방법</summary>
  
![image](https://github.com/hanseul9/algorithm/assets/102939057/25bfe661-df01-4f43-9c0e-cbb1d070aab9)

  
1. 주어진 리스트를 절반으로 분할하여 부분리스트로 나눈다. (Divide : 분할)
  
2. 해당 부분리스트의 길이가 1이 아니라면 1번 과정을 되풀이한다. (재귀 함수)
   
3. 인접한 부분리스트끼리 정렬하여 합친다. (Conqure : 정복)
  
  * 주의할 점은 각각의 부분 리스트는 정렬된 상태이다.
  * 합치는 과정에서 추가로 배열이 필요함 
</details>

  
